## 数据结构（The data structure）

### 树

* 遍历方式
    * 先序遍历：
    * 中序遍历
    * 后序遍历
    * 层次遍历
    


#### 二叉树

* 非空二叉树第 i 层最多 2^(i-1) 个结点
* 深度为 k 的二叉树最多 2^k -i 个结点
* 有 n 个结点的完全二叉树深度 k = log2(n) + 1
* 度为 0 的结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1


#### 八叉树

* 又称为八元树，是一种用于描述三位空间的树状数据结构
* 八叉树的每个结点表述一个正方体的体积元素

## 算法

### 排序

排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性
---|---|---|---|---
[冒泡排序] | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定
[选择排序] | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|数组不稳定、链表稳定
[插入排序] | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定
[快速排序] | O(n*log<sub>2</sub>n) |  O(n<sup>2</sup>) | O(log<sub>2</sub>n) | 不稳定
[堆排序] | O(n*log<sub>2</sub>n)|O(n*log<sub>2</sub>n)|O(1)|不稳定
[归并排序] | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n)|O(n)|稳定
[希尔排序] | O(n*log<sup>2</sup>n)|O(n<sup>2</sup>)|O(1)|不稳定
[计数排序] | O(n+m)|O(n+m)|O(n+m)|稳定
[桶排序] | O(n)|O(n)|O(m)|稳定
[基数排序] | O(k*n)|O(n<sup>2</sup>)| |稳定

> * 均按从小到大排列
> * k：代表数值中的 “数位” 个数
> * n：代表数据规模
> * m：代表数据的最大值减最小值

### 查找

查找算法 | 平均时间复杂度 | 空间复杂度 | 查找条件
---|---|---|---
[顺序查找] | O(n) | O(1) | 无序或有序
[二分查找（折半查找）] | O(log<sub>2</sub>n)| O(1) | 有序
[插值查找] | O(log<sub>2</sub>(log<sub>2</sub>n)) | O(1) | 有序
[斐波那契查找] | O(log<sub>2</sub>n) | O(1) | 有序
[哈希查找] | O(1) | O(n) | 无序或有序
[二叉查找树（二叉搜索树查找）] |O(log<sub>2</sub>n) |   | 
[红黑树] |O(log<sub>2</sub>n) | |
2-3树 | O(log<sub>2</sub>n - log<sub>3</sub>n) |   | 
B树/B+树 |O(log<sub>2</sub>n) |   | 

### 图搜索算法

图搜索算法 |数据结构| 遍历时间复杂度 | 空间复杂度
---|---|---|---
[BFS广度优先搜索]|邻接矩阵<br/>邻接链表|O(\|v\|<sup>2</sup>)<br/>O(\|v\|+\|E\|)|O(\|v\|<sup>2</sup>)<br/>O(\|v\|+\|E\|)
[DFS深度优先搜索]|邻接矩阵<br/>邻接链表|O(\|v\|<sup>2</sup>)<br/>O(\|v\|+\|E\|)|O(\|v\|<sup>2</sup>)<br/>O(\|v\|+\|E\|)

### 其他算法

算法 |思想| 应用
---|---|---
[分治法]|把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并|循环赛日程安排问题、排序算法（快速排序、归并排序）
[动态规划]|通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题|背包问题、斐波那契数列
[贪心法]|一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法|旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码

## 操作系统

* 进程是资源分配的独立单位
* 线程是资源调度的独立单位

### 网络运输层

协议：TCP（Transmission Control Protocol，传输控制协议）、UDP（User Datagram Protocol，用户数据报协议）

TCP 是一种面向连接的、可靠的、基于字节流的传输层通讯协议、其传输的单元的报文段。

面向连接、只能点对点通讯、可靠交互、全双工通讯、面向字节流

TCP 保障可靠传输：确认和超时重试、数据合理分片和排序、流量控制、拥塞控制、数据校验








UDP 是OSI（Open System Interconnection 开放式系统互联）参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传输服务，其传输的单元是用户数据报。

无连接、尽最大努力交付、面向报文、没有拥塞控制、支持一对一、一对多、多对一、多对多的交互通信、首部开销小


TCP与UDO的区别

1. TCP面向连接；UDP是无连接的。
2. TCP提供可靠的服务，也就是说，通过TCP连接传送的数据无差错、不丢失、不重复且按序到达；UDP尽最大努力交付，即不保证可靠交付。
3. TCP的逻辑通信信道的全双工的可靠信道; UDP则是不可靠信道。
4. 每一条TCP连接只能是点到点；UDP支持一对一、一对多、多对一、多对多的交互通。
5. TCP面向字节流，可能出现黏包问题，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，不会出现黏包问题。
6. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低，对实际应用很有用，如IP电话、实时视频会议等。
7. TCP首部开销20字节，UDP的首部开销只有8个字节。

TCP黏包问题

> TCP 是一个基于字节流的传输服务（UDP基于报文），“流”意味着TCP所传输的数据是没有边界的，所以可能会出现两个数据包黏在一起的情况。

* 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只能累计接收数据，直到数据等于一个定长的数值就将它作为一个完整消息。
* 包头加上包体长度。包长是定长的4个字节，说明了包体的长度。接收对等方先接收包头长度，然后依据包头长度来接收包体。
* 在数据包之间设置边界，如添加特殊符号标记。FTP协议正是这么做的。但问题在于如果数据正文只也包含有特殊标记，则会误判为消息的边界。
* 使用更复杂的应用层协议。

TCP流量控制

概念:流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。

方法: 利用可变窗口进行流量控制。

TCP拥塞控制

概念：拥塞控制就是为了防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载。

方法：慢开始、拥塞避免、快重传、快恢复

TCP传输连接管理

TCP三次握手连接: client(SYN=1,seq=x)->server(SYN=1,ACK=1,seq=y,ack=x+1)->client(ACK=1,seq=x+1,ack=y+1)

客户端请求建立连接->服务器回复同意建立连接->客户端回复收到服务器的同意报文

为什么需要进行三次握手：因为信道不可靠，TCP想在不可靠信道上建立可靠传输，双方都需要确认对方收到了自己发送的序列号，确认过程最少需要三次。

TCP四次挥手释放连接: client(FIN=1,seq=u)->server(ACK=1,seq=v,ack=u+1) server->client(数据传输) server(FIN=1,ACK=1,seq=w,ack=u+1)->client(ACK=1,seq=u+1,ack=w+1)

客户端请求释放连接->同意释放连接 服务器请求释放连接-> 同意释放连接

为什么需要进行四次挥手: 因为TCP是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（第一二次挥手），服务端继续传输之前没有传完的数据给客户端，服务端向客户端的连接关闭（第三四次挥手）,
所以TCP释放连接时服务器的ACK和FIN是分开发送的，中间隔着数据传输，而TCP建立连接时服务器的ACK和SYN是一起发送的，所以TCP建立连接需要三次，而释放连接需要四次。

客户端请求释放连接时，服务器可能还有数据需要传输给客户端，因此服务器要先响应客户端FIN请求（服务器回复ACK），然后进行数据传输，传输完成后，服务器再提出FIN请求。








